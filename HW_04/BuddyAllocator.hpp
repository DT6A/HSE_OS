#pragma once

#include <cstdint>

#include <sys/user.h>

namespace hse::arch_os {
    /**
     * BuddyAllocator используется в качестве базового аллокатора. В данном задании, правда, мы его
     * будем реализовывать управляя не физической памятью на уровне операционной системы, а управляя
     * регионом выделенной виртуальной памяти в рамках процесса. Промышленный аллокатор должен уметь
     * работать и набором отрезков памяти а также быть корректен в многопоточных и многопроцессорных
     * системах, но в рамках этого задания мы откинем эти требования.
     *
     * Buddy allocator позваляет выделять страницы памяти или несколько подряд идущих страниц, но не
     * произвольно:
     * 0. Выделяемая память должна соотвествовать страницам памяти, а не быть произвольным отрезком
     *    памяти соотвествующего размера.
     * 1. Число выделяемых страниц является степенью двойки, от одной (нулевая степень) до
     *    2^MAX_ORDER (MAX_ORDER). Далее показатель этой степени для выделенного отрезка будет
     *    называется его уровнем.
     * 2. Номер начальной страницы выделенного куска должен делиться на
     *    2^уровень. Если смотреть на адрес, он должен делиться на PAGESIZE << уровень.
     *
     * Таким образом возможные к выделению страницы образуют двоичное дерево, в котором относительно
     * легко находить родственные веришны (отсюда приятель, buddy) без дополнительной памяти (потому
     * что, вообще говоря, нам её откуда-то надо взять).
     *
     * Например, если аллокатору передать отрезок страниц от 1 до 10 включительно:
     *          0    1    2    3    4    5    6    7    8    9    10
     * Memory:  |----|====|====|====|====|====|====|====|====|====|
     * Level 0:      |====|====|====|====|====|====|====|====|====|
     * Level 1:           |=========|=========|=========|=========|
     * Level 2:                     |===================|
     * ...
     *
     * Если каждую свободную страницу в этом дереве поднимать до самого высокого
     * уровня и объединить вершины каждого уровня в список, то выделение и
     * освобождение памяти будет довольно эффективно.
     *
     * Например:
     *  Pages:   0    1    2    3    4    5    6    7    8    9    10
     *  Level 0: - - >|====|- - - - - - - - - - - - - - - - - - - x
     *  Level 1: - - - - ->|=========|< - - - - - - - - >|=========|
     *  Level 2: - - - - - - - - - ->|===================|- - - - x
     *  ...
     *
     *  При необходимости страницы более высокого уровня можно разделить на две более низкого, а при
     *  освобождении, наоборот, объединить до более высокого.
     *
     *  Чтобы отслеживать занятость и текущий уровень элементов дерева вам потребуется
     *  дополнительная память, воспользуйтесь фрагментом выданной аллокатору памяти. Пользоваться
     *  какой-либо другой памятью, кроме (весьма конечных) полей класса и переданной в конструктор
     *  памяти запрещено.
     */
    class BuddyAllocator {
    public:
        /**
         * Размер страницы, используемой аллокатором.
         */
        static constexpr std::size_t PAGESIZE = PAGE_SIZE;

        /*
         * Максимальный уровень выделяемой памяти.
         */
        static constexpr std::ptrdiff_t MAX_ORDER = 20;
    private:
        static constexpr std::ptrdiff_t ORDERS = MAX_ORDER + 1;
    public:

        /**
         * Создаёт аллокатор на заданном отрезке памяти. Гарантируется, что этот отрезок
         * начинается на границе страницы, заканчивается на границе странице, и простилается
         * хотя бы 2 страницы.
         * @param memoryStart начало управляемой памяти. Численно делится на `PAGESIZE`.
         * @param memoryLength длина управляемой памяти. Численно делится на `PAGESIZE`.
         *
         * Время работы: O(MAX_ORDER + memoryLength). Рекомендую посильнее поделить последнее
         * слагаемое.
         */
        BuddyAllocator(void *memoryStart, std::size_t memoryLength);

        /**
         * Выделяет память. Возращает `nullptr` в случае неудачи.
         * @param order уровень выделяемой памяти, т.е. показатель степени длины выделяемого
         *               фрагмента, измеренной в страницах.
         *
         * Время работы: O(MAX_ORDER).
         */
        void *allocate(std::size_t order);
        /**
         * Освобождает ранее выделенную память. Попытка освободить память, не полученнную до
         * этого из `allocate` этого же аллокатора или освободить повторно — неопределённое
         * поведение.
         * @param memory начало освобождаемой памяти.
         *
         * Время работы: O(MAX_ORDER).
         * */
        void deallocate(void *memory);

    private:
        /*
         * Внутренняя реализация на ваше усмотрение.
         * Помните, что пользоваться кучей или глобальными переменными нельзя.
         */
        static constexpr std::size_t maxNumberOfDescriptors = (static_cast<std::size_t >(1) << ORDERS) - 1;
        static constexpr std::size_t memorySizeForLists = MAX_ORDER * sizeof(std::size_t);


        static std::size_t calculateFullTreeSizeFromMemLen(std::size_t memoryLength);

        struct Descriptor {
            bool isFree = true;
            void* memPtr = nullptr;

            std::size_t next = -1, prev = -1;
        };

        Descriptor *descriptors;
        std::size_t *lists;
        char *memTreeLimit;
        std::size_t localMaxOrder;
        bool isFullTree = false;

        void buildTree(std::size_t v, std::size_t l, std::size_t r, char *mem, std::size_t level);
        void removeFromList(std::size_t node, std::size_t listId);
        void addToList(std::size_t node, std::size_t listId);
        static std::size_t getBuddy(std::size_t node);
    };
}